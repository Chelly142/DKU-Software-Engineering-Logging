# Process Programming
- 프로세스와 관련된 시스템 콜 
- 새로운 프로세스 생성 방법
- 새로은 프로그램 실행 방법
- 쉘에대한 이해
- 멀티테스킹 시스템 이해

## 프로세스 관련 시스템 콜
- fork(),clone() : 프로세스 생성, task_struct 생성(inode와 비슷 pid와 메모리 정보를 저장)
- execve() : 새로운 프로그래 실행(binary loader)
- exit() :  프로세스 종료
- wait(), waitpid() : 프로세스를 잠시 멈춤(자식 프로세스 종료 대기)
- getpid() : 프로세스 id를 얻음

### fork()
- 세로운 프로세스를 만든다 기존의 프로세스를 메모리에서 그대로 복사 가져옴
- 기존의 프로세스는 부모 프로세스 새로 만들어진 프로세스를 자식 프로세스라고함
- 리턴 값이 2개이다. 부모의 리턴값(자식 pid 항상 0보다큼)과 자식의 리턴값(0)
- fork()를 만난순간부터 그 이후의 제어흐름이 2개로 나뉜다.
- fork() 수행 시 메모리에 text는 읽을 수만 있으므로 부모와 자식이 공유하고 stack과 data는 복사해서 새로 만들어진다.
- 따라서 부모와 자식은 서로 독립되어있어 서로 영향을 끼치거나 변화를 알거나 할 수 없다.

### execve()
- 새로운 프로그램을 수행 시키는 시스템 콜
- exec이 성공하면 기존의 프로세스에서 새로 실행된 프로그램 프로세스로 대체되어 다음 코드는 실행되지 않는다.
- execve() 실행시 대상 프로그램을 디스크로부터 메모리로 올린 후 process의 메모리 이미지를 교체한다.
- 메인 함수는 최대 3개의 인자를 받는데 인자수, 인자값들, 환경변수 가있다.
- 환경변수는 터미널 정보를 결정
- 인자를 따로 나열하면 list, 배열로 묶어 전달하면 vector이다
- 리눅스에서 오브젝트 파일은 elf 구조를 따르기 떄문에 프로세스 구조와 비슷하고 관련이 되어있다.

### Shell
- 커멘드 해석기
- 기본 동작 구조 
  - prompt를 띄우고 입력을 parsing 한다
  - 외부 명령어의 경우 fork()하고 자식 프로세스에서 execve()을 해준다.
  - 내부 명령어의 경우 그냥 처리
- Shell 고급기능
  - background processing : &, wait()를 사용 안하면 됨
  - rediraction : >, execve()전에 dup2()를 사용해 원하는 파일디스크립터로 바꿔준다.
  - pipe : |, 프로세스간의 커뮤니케이션
  - Shell script


